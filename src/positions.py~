"""
*************** POSITION ANALYSIS *******************

PROGRAM INPUT:
	       

PROGRAM OUTPUT: 
		
		

***************************************************************
Created 11/12/15 by Frank Longford

Last modified 10/05/16 by Frank Longford
"""

import numpy as np
import scipy as sp
import subprocess, time, sys, os, math, copy
import matplotlib.pyplot as plt

from scipy import stats
from scipy import constants as con
from scipy.optimize import curve_fit, leastsq
import scipy.integrate as spin
from scipy.interpolate import bisplrep, bisplev, splprep, splev

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.cm as cm
from matplotlib.colors import BoundaryNorm
from matplotlib.ticker import MaxNLocator

import utilities as ut
import intrinsic_surface as IS


def mass_profile(traj, root, nimage, nslice, natom, model, folder, csize, suffix, DIM, overwrite_all):
	"Returns parameters for the density function, fitted to nimage number of snapshots" 

	if not os.path.exists("{}/DATA/DEN".format(root)): os.mkdir("{}/DATA/DEN".format(root))
	nsite, AT, Q, M, LJ = ut.get_param(model)
	if model.upper() == 'METHANOL': com = 'COM'
	else: com = 0
	print ""
	print "CALCULATING DENSITY OF {} {} SIZE {}\n".format(model.upper(), folder.upper(), csize)

	xR = np.zeros(nimage)
	yR = np.zeros(nimage)
	zR = np.zeros(nimage)

	dist = 0

	mass_count = np.zeros(nslice)
	atom_count = np.zeros(nslice)
	mol_count = np.zeros(nslice)
	H_count = np.zeros(nslice)

	av_mass_den = np.zeros(nslice)
	av_atom_den = np.zeros(nslice)
	av_mol_den = np.zeros(nslice)
	av_H_den = np.zeros(nslice)

	avpl = []
	avpv = []
	avden = []
	avz0 = []
	
	Z1 = np.linspace(0, DIM[2], nslice)
	Z2 = np.linspace(-1/2.*DIM[2], 1/2.*DIM[2], nslice)

	dz = DIM[2] / nslice
	Vslice = DIM[0] * DIM[1] * dz
	Acm = 1E-8
	start_image = 0

	for image in xrange(nimage):
		if os.path.exists('{}/DATA/DEN/{}_{}_{}_{}_COUNT.txt'.format(root, model.lower(), csize, nslice, image)) and overwrite_all.upper() != 'Y':
			start_image = image + 1
			with file('{}/DATA/DEN/{}_{}_{}_{}_COUNT.txt'.format(root, model.lower(), csize, nslice, image)) as infile:
				mass_count, atom_count, mol_count, H_count = np.loadtxt(infile)

			av_mass_den += mass_count / (nimage * Vslice * con.N_A * Acm**3)
			av_atom_den += atom_count / (nimage * Vslice)
			av_mol_den += mol_count / (nimage * Vslice)
			av_H_den += H_count / (nimage * Vslice)


	for image in xrange(start_image, nimage):
		sys.stdout.write("PROCESSING {} out of {} IMAGES\r".format(image+1, nimage) )
		sys.stdout.flush()
		mass_count = np.zeros(nslice)
		atom_count = np.zeros(nslice)
		mol_count = np.zeros(nslice)
		H_count = np.zeros(nslice)

		ZYX = np.rot90(traj.xyz[image])
		zat = ZYX[0] * 10
		yat = ZYX[1] * 10
		xat = ZYX[2] * 10

		#xat, yat, zat = ut.read_positions("{}/{}_{}_{}{}.rst".format(root, model.lower(), csize, suffix, image), nsite)		
		xmol, ymol, zmol = ut.molecules(xat, yat, zat, nsite, M, com=com)
		xR[image], yR[image], zR[image] = ut.centre_mass(xat, yat, zat, nsite, M)
		
		for n in xrange(natom):
			z = (zat[n]-zR[image] + 0.5*DIM[2])
			index_at = int(z * nslice / DIM[2]) % nslice
			m = n % nsite
			mass_count[index_at] += M[m]
			atom_count[index_at] += 1 
			if m == 0:
				z = (zmol[n/nsite]-zR[image] + 0.5*DIM[2])
				index_mol = int(z * nslice / DIM[2]) % nslice
				mol_count[index_mol] += 1
				
			if AT[m]== 'H': H_count[index_at] += 1

		av_mass_den += mass_count / (nimage * Vslice * con.N_A * Acm**3)
		av_atom_den += atom_count / (nimage * Vslice)
		av_mol_den += mol_count / (nimage * Vslice)
		av_H_den += H_count / (nimage * Vslice)

		"""
		fig = plt.figure(1)
		A, B = curve_fit(ut.den_func, zscale, run_mass_den, [1., 0., DIM[2]/2., DIM[2]/4., 2.])
		p1 = map (lambda z: ut.den_func(z, A[0], A[1], A[2], A[3], A[4]) , zscale)
		plt.plot(zscale, p1)
		#plt.plot(zscale, run_mass_den)
		"""
		with file('{}/DATA/DEN/{}_{}_{}_{}_COUNT.txt'.format(root, model.lower(), csize, nslice, image), 'w') as outfile:
			np.savetxt(outfile, (mass_count, atom_count, mol_count, H_count), fmt='%-12.6f')		
	
	print "\n"

	param, _ = curve_fit(ut.den_func, Z1, av_mass_den, [1., 0., DIM[2]/2., DIM[2]/4., 2.])
	param = np.absolute(param)
	
	print "WRITING TO FILE..."

	with file('{}/DATA/DEN/{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), csize, nslice, nimage), 'w') as outfile:
		np.savetxt(outfile, (av_mass_den, av_atom_den, av_mol_den, av_H_den), fmt='%-12.6f')

	with file('{}/DATA/DEN/{}_{}_{}_{}_PAR.txt'.format(root, model.lower(), csize, nslice, nimage), 'w') as outfile:
		np.savetxt(outfile, param, fmt='%-12.6f')

	with file('{}/DATA/DEN/{}_{}_{}_COM.txt'.format(root, model.lower(), csize, nimage), 'w') as outfile:
		np.savetxt(outfile, (xR, yR, zR), fmt='%-12.6f')

	print "{} {} {} COMPLETE\n".format(root, model.upper(), csize)



def intrinsic_profile(traj, root, nimage, nslice, ncube, natom, model, csize, suffix, DIM, vlim, nxy, ow_coeff, ow_count, ow_curve):

	print ""
	print "CALCULATING INTRINSIC DENSITY OF {} {} SIZE {}\n".format(model.upper(), suffix.upper(), csize)

	nsite, AT, Q, M, LJ = ut.get_param(model)
	sigma = np.max(LJ[1])
	nm = int((DIM[0] + DIM[1]) / (2 * sigma) )
	if model.upper() == 'METHANOL': com = 'COM'
	else: com = '0'

	dz = DIM[2] / nslice
	Aslice = DIM[0]*DIM[1]
	Vslice = DIM[0]*DIM[1]*dz
	Acm = 1E-8

	av_mass_den = np.zeros(nslice)
	av_atom_den = np.zeros(nslice)
	av_mol_den = np.zeros(nslice)
	av_H_den = np.zeros(nslice)

	X = np.linspace(0, DIM[0], nxy)
	Y = np.linspace(0, DIM[1], nxy)
	Z1 = np.linspace(0, DIM[2], nslice)
	Z2 = np.linspace(-1/2.*DIM[2], 1/2.*DIM[2], nslice)

	phi = 5E-2
	tau = 0.4 * sigma

	n0 = Aslice * 1.1 / sigma**2
	qu = nm

	start_image_count = 0
	start_image_curve = 0

	for image in xrange(nimage):

		auv1, auv2, piv_n1, piv_n2 = IS.intrinsic_surface(traj, root, model, csize, suffix, nsite, ncube, DIM, vlim, sigma, M, nm, ow_coeff, image, nimage, com)
		IS.curve_mesh(root, model, csize, nm, nxy, image, auv1, auv2, DIM, ow_curve)
		mass_count, atom_count, mol_count, H_count = IS.intrinsic_density(traj, root, model, csize, suffix, nm, image, nslice, nsite, AT, DIM, M, nxy, auv1, auv2, com, ow_count)						  
		av_mass_den += mass_count / (2 * dz * nimage * con.N_A * Acm**3)
		av_atom_den += atom_count / (2 * dz * nimage)
		av_mol_den += mol_count / (2 * dz * nimage)
		av_H_den += H_count / (2 * dz * nimage)

	print "\nBUILDING SLAB DENSITY PLOT"

	w_den_1 = np.zeros(nslice)
	w_den_2 = np.zeros(nslice)

	for image in xrange(nimage):
		sys.stdout.write("PROCESSING {} out of {} IMAGES\r".format(image+1, nimage) )
		sys.stdout.flush()

		if os.path.exists('{}/DATA/INTDEN/{}_{}_{}_{}_{}_WDEN.txt'.format(root, model.lower(), csize, nslice, nm, image)):
			with file('{}/DATA/INTDEN/{}_{}_{}_{}_{}_WDEN.txt'.format(root, model.lower(), csize , nslice, nm, image), 'r') as infile:
				w_den_1_temp, w_den_2_temp = np.loadtxt(infile)

		else:
			w_den_1_temp = np.zeros(nslice)
			w_den_2_temp = np.zeros(nslice)
		
			with file('{}/DATA/INTDEN/{}_{}_{}_{}_{}_CURVE.npz'.format(root, model.lower(), csize, nm, nxy, image), 'r') as infile:
				npzfile = np.load(infile)
				XI1 = npzfile['XI1']
				XI2 = npzfile['XI2']

			for n in xrange(nslice):
				z = Z2[n]

				for j in xrange(nxy):
					for k in xrange(nxy):
						dz = z - XI1[j][k]
						m = int((dz+DIM[2]/2.) * nslice / DIM[2]) % nslice
						w_den_1_temp[n] += av_mol_den[m] / (nxy**2)

						dz = XI2[j][k] - z
						m = int((dz+DIM[2]/2.) * nslice / DIM[2]) % nslice
						w_den_2_temp[n] += av_mol_den[m] / (nxy**2)
			
			with file('{}/DATA/INTDEN/{}_{}_{}_{}_{}_WDEN.txt'.format(root, model.lower(), csize , nslice, nm, image), 'w') as outfile:
				np.savetxt(outfile, (w_den_1_temp, w_den_2_temp))
	
		w_den_1 += w_den_1_temp / nimage
		w_den_2 += w_den_2_temp / nimage

	plt.figure(20)
	plt.plot(Z2, w_den_1)
	plt.plot(Z2, w_den_2)
	plt.show()

	print '\n'
	print "WRITING TO FILE..."

	with file('{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), csize, nslice, nm, nimage), 'w') as outfile:
		np.savetxt(outfile, (av_mass_den, av_atom_den, av_mol_den, av_H_den, w_den_1, w_den_2), fmt='%-12.6f')

	print "{} {} {} COMPLETE\n".format(root, model.upper(), csize)



def ddelta(x, phi):

	if -phi < x and x < phi: return 1./(2*phi) + (1 + np.cos(np.pi * x / phi))
	else: return 0

def slice_area(auv, nm, z):

	Axi = 0
	for j in xrange((2*nm+1)**2):
		xi2 = np.real(auv[j]*np.conj(auv[j]))
		Axi += xi2 / (1 + xi2 * abs(z) * j**2)**2
	return 1 + 0.5*Axi

def get_histograms(root, nimage, nslice, Vslice):
	proc = subprocess.Popen('ls {}/DATA/INTDEN/*DEN.txt'.format(root), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	out, err = proc.communicate()
	files = out.split()
	length = len(root) + 6
	size = 0
	
	for i in xrange(len(files)):
		temp = files[i]
		temp = temp[length:-1]
		temp = temp.split('_')
		if int(temp[3]) > size and int(temp[3]) < nimage: 
			size = int(temp[3])
			k = i
	
	if size == 0: return 0, np.zeros(nslice), np.zeros(nslice), np.zeros(nslice)

	with file(files[k], 'r') as infile:
		av_mass_den, av_atom_den, av_mol_den= np.loadtxt(infile)
	
	mass_count = av_mass_den * size * Vslice * con.N_A * (1E-8)**3
	atom_count = [int(av_atom_den[j] * size * Vslice) for j in xrange(nslice)]
	mol_count = [int(av_mol_den[j] * size * Vslice) for j in xrange(nslice)]
	
	return size, mass_count, atom_count, mol_count

def get_fourier(auv, nm):

	f = np.zeros(len(auv))

	for u in xrange(-nm,nm+1):
		for v in xrange(-nm, nm+1):
			index = (2 * nm + 1) * (u + nm) + (v + nm)

			j1 = (2 * nm + 1) * (abs(u) + nm) + (abs(v) + nm)
			j2 = (2 * nm + 1) * (-abs(u) + nm) + (abs(v) + nm)
			j3 = (2 * nm + 1) * (abs(u) + nm) + (-abs(v) + nm)
			j4 = (2 * nm + 1) * (-abs(u) + nm) + (-abs(v) + nm)

			if u == 0: f[index] = (auv[j1] - np.sign(v) * 1j * auv[j3]) / 2.

			elif v == 0: f[index] = (auv[j1] - np.sign(u) * 1j * auv[j2]) / 2.

			elif u < 0 and v < 0: f[index] = (auv[j1] + 1j * (auv[j2] + auv[j3]) - auv[j4]) / 4.
			elif u > 0 and v > 0: f[index] = (auv[j1] - 1j * (auv[j2] + auv[j3]) - auv[j4]) / 4.

			elif u < 0: f[index] = (auv[j1] + 1j * (auv[j2] - auv[j3]) + auv[j4]) / 4.
			elif v < 0: f[index] = (auv[j1] - 1j * (auv[j2] - auv[j3]) + auv[j4]) / 4.

	return f

def eul_profile(traj, root, nimage, nslice, nmol, model, csize, suffix, DIM, nsite, a_type, nm, nxy, ow_P):

	print ""
	print "CALCULATING ORIENTATIONS OF {} {} SIZE {}\n".format(model.upper(), suffix.upper(), csize)	

	MOLECULES = np.zeros((nimage, nmol, nsite, 3))
	nsite, AT, Q, M, LJ = ut.get_param(model)
	npi = 50
	if model.upper() == 'METHANOL': com = 'COM'
	else: com = '0'

	X = np.linspace(0, DIM[0], nxy)
	Y = np.linspace(0, DIM[1], nxy)
	Z1 = np.linspace(0, DIM[2], nslice)
	Z2 = np.linspace(-1/2.*DIM[2], 1/2.*DIM[2], nslice)

	with file('{}/DATA/DEN/{}_{}_{}_COM.txt'.format(root, model.lower(), csize, nimage), 'r') as infile:
		xR, yR, zR = np.loadtxt(infile)
		if nimage == 1: zR = [zR]

	with file('{}/DATA/DEN/{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), csize, nslice, nimage), 'r') as infile:
		av_mass_den, av_atom_den, av_mol_den, av_H_den = np.loadtxt(infile)

	with file('{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), csize, nslice, nm, nimage), 'r') as infile:
		int_av_mass_den, int_av_atom_den, int_av_mol_den, int_av_H_den, w_den_1, w_den_2 = np.loadtxt(infile)

	DEN = av_mol_den

	P_z_theta_phi_varphi = np.zeros((nslice,npi,npi,npi))
	rho_z_theta = np.zeros((nslice,npi))
	rho_z_phi = np.zeros((nslice,npi))
	rho_z_varphi = np.zeros((nslice,npi))
	mol_count = np.zeros(nslice)

	int_P_z_theta_phi_varphi1 = np.zeros((nslice,npi,npi,npi))
	int_rho_z_theta1 = np.zeros((nslice,npi))
	int_rho_z_phi1 = np.zeros((nslice,npi))
	int_rho_z_varphi1 = np.zeros((nslice,npi))
	int_mol_count1 = np.zeros(nslice)

	int_P_z_theta_phi_varphi2 = np.zeros((nslice,npi,npi,npi))
	int_rho_z_theta2 = np.zeros((nslice,npi))
	int_rho_z_phi2 = np.zeros((nslice,npi))
	int_rho_z_varphi2 = np.zeros((nslice,npi))
	int_mol_count2 = np.zeros(nslice)

	z_array = np.zeros((nimage, nmol))
	theta = np.zeros((nimage, nmol))
	phi = np.zeros((nimage, nmol))
	varphi = np.zeros((nimage, nmol))

	zeta_array1 = np.zeros((nimage, nmol))
	int_theta1 = np.zeros((nimage, nmol))
	int_phi1 = np.zeros((nimage, nmol))
	int_varphi1 = np.zeros((nimage, nmol))

	zeta_array2 = np.zeros((nimage, nmol))
	int_theta2 = np.zeros((nimage, nmol))
	int_phi2 = np.zeros((nimage, nmol))
	int_varphi2 = np.zeros((nimage, nmol))

	""" Cycle through existing ANGLE files""" 
	start_image_P = 0

	for image in xrange(nimage):
		sys.stdout.write("CHECKING {} out of {} ANGLE files\r".format(image+1, nimage) )
		sys.stdout.flush()
		if os.path.exists('{}/DATA/EULER/{}_{}_{}_ANGLE.txt'.format(root, model.lower(), csize, image)) and ow_P.upper() != 'Y':
			start_image_P = image + 1
			with file('{}/DATA/EULER/{}_{}_{}_ANGLE.txt'.format(root, model.lower(), csize, image), 'r') as infile:
				z_array[image], theta[image], phi[image], varphi[image] = np.loadtxt(infile)
			with file('{}/DATA/INTEULER/{}_{}_{}_{}_ANGLE1.txt'.format(root, model.lower(), csize, nm, image), 'r') as infile:
				zeta_array1[image], int_theta1[image], int_phi1[image], int_varphi1[image] = np.loadtxt(infile)
			with file('{}/DATA/INTEULER/{}_{}_{}_{}_ANGLE2.txt'.format(root, model.lower(), csize, nm, image), 'r') as infile:
				zeta_array2[image], int_theta2[image], int_phi2[image], int_varphi2[image] = np.loadtxt(infile)
		sys.stdout.write(" "*80 + "\r")
	print "FOUND {} out of {} ANGLE files\n".format(start_image_P, nimage)

	for image in xrange(start_image_P, nimage):
		sys.stdout.write("PROCESSING {} out of {} ANGLE files\r".format(image+1, nimage) )
		sys.stdout.flush()

		with file('{}/DATA/ACOEFF/{}_{}_{}_{}_INTCOEFF.txt'.format(root, model.lower(), csize, nm, image), 'r') as infile:
			auv1, auv2 = np.loadtxt(infile)

		ZYX = np.rot90(traj.xyz[image])
		zat = ZYX[0] * 10
		yat = ZYX[1] * 10
		xat = ZYX[2] * 10

		#xat, yat, zat = ut.read_positions("{}/{}_{}_{}{}.rst".format(root,model.lower(), csize, suffix, image), nsite)
		xmol, ymol, zmol = ut.molecules(xat, yat, zat, nsite, M, com)
		xR, yR, zR = ut.centre_mass(xat, yat, zat, nsite, M)

		for j in xrange(nmol):
			for l in xrange(nsite):
				MOLECULES[image][j][l][0] = xat[j*nsite+l]
				MOLECULES[image][j][l][1] = yat[j*nsite+l]
				MOLECULES[image][j][l][2] = zat[j*nsite+l]

			zeta1 = zmol[j] - zR - IS.xi(xmol[j], ymol[j], nm, auv1, DIM) 
			dzx1, dzy1 = IS.dxyi(xmol[j], ymol[j], nm, auv1, DIM)
			
			zeta2 = - zmol[j] + zR + IS.xi(xmol[j], ymol[j], nm, auv2, DIM)			
			dzx2, dzy2 = IS.dxyi(xmol[j], ymol[j], nm, auv2, DIM)

			T = local_frame_molecule(MOLECULES[image][j], model) 
			z_array[image][j] = zmol[j] - zR
			theta[image][j] = np.arccos(T[2][2])
			phi[image][j] = np.arctan2(-T[2][0],T[2][1])
			varphi[image][j] = np.arctan2(T[0][2],T[1][2])
	
			
			zeta_array1[image][j] = zeta1
			int_theta1[image][j] = np.arccos(T[2][2])
			int_phi1[image][j] = np.arctan2(-T[2][0],T[2][1])
			int_varphi1[image][j] = np.arctan2(T[0][2],T[1][2])

			zeta_array2[image][j] = zeta2
			int_theta2[image][j] = np.arccos(T[2][2])
			int_phi2[image][j] = np.arctan2(-T[2][0],T[2][1])
			int_varphi2[image][j] = np.arctan2(T[0][2],T[1][2])

			"""
			O = ut.local_frame_surface(dzx1, dzy1, zeta1, zR[image])
			T1 = np.dot(T, np.linalg.inv(O))
			if T1[2][2] < -1: T1[2][2] = -1.0
			elif T1[2][2] > 1: T1[2][2] = 1.0
			zeta_array1[image][j] = zeta1
			int_theta1[image][j] = np.arccos(T1[2][2])
			int_phi1[image][j] = np.arctan2(-T1[2][0],T1[2][1])
			int_varphi1[image][j] = np.arctan2(T1[0][2],T1[1][2])

			O = ut.local_frame_surface(dzx2, dzy2, zeta2, zR[image])
			T2 = np.dot(T, np.linalg.inv(O))
			if T2[2][2] < -1: T2[2][2] = -1.0
			elif T2[2][2] > 1: T2[2][2] = 1.0
			zeta_array2[image][j] = zeta2
			int_theta2[image][j] = np.arccos(T2[2][2])
			int_phi2[image][j] = np.arctan2(-T2[2][0],T2[2][1])
			int_varphi2[image][j] = np.arctan2(T2[0][2],T2[1][2])
			"""

		with file('{}/DATA/EULER/{}_{}_{}_ANGLE.txt'.format(root, model.lower(), csize, image), 'w') as outfile:
			np.savetxt(outfile, (z_array[image], theta[image], phi[image], varphi[image]), fmt='%-12.6f')
		with file('{}/DATA/INTEULER/{}_{}_{}_{}_ANGLE1.txt'.format(root, model.lower(), csize,  nm, image), 'w') as outfile:
			np.savetxt(outfile, (zeta_array1[image], int_theta1[image], int_phi1[image], int_varphi1[image]), fmt='%-12.6f')
		with file('{}/DATA/INTEULER/{}_{}_{}_{}_ANGLE2.txt'.format(root, model.lower(), csize, nm, image), 'w') as outfile:
			np.savetxt(outfile, (zeta_array2[image], int_theta2[image], int_phi2[image], int_varphi2[image]), fmt='%-12.6f')

	for i in xrange(nimage):
		for j in xrange(nmol):
			
			z = z_array[i][j] + DIM[2]/2.
			index1 = int(z * nslice / DIM[2]) % nslice
			index2 = int(theta[i][j] * npi / np.pi) % npi
			index3 = int(phi[i][j] * npi / np.pi) % npi
			index4 = int(varphi[i][j] * npi / np.pi) % npi

			P_z_theta_phi_varphi[index1][index2][index3][index4] += 1
			rho_z_theta[index1][index2] += 1
			rho_z_phi[index1][index3] += 1
			rho_z_varphi[index1][index4] += 1
			mol_count[index1] += 1
	
			z = zeta_array1[i][j] + DIM[2]/2.
			index1 = int(z * nslice / DIM[2]) % nslice
			index2 = int(int_theta1[i][j] * npi / np.pi) % npi
			index3 = int(int_phi1[i][j] * npi / np.pi) % npi
			index4 = int(int_varphi1[i][j] * npi / np.pi) % npi

			int_P_z_theta_phi_varphi1[index1][index2][index3][index4] += 1
			int_rho_z_theta1[index1][index2] += 1
			int_rho_z_phi1[index1][index3] += 1
			int_rho_z_varphi1[index1][index4] += 1
			int_mol_count1[index1] += 1

			z = zeta_array2[i][j] + DIM[2]/2.
			index1 = int(z * nslice / DIM[2]) % nslice
			index2 = int(int_theta2[i][j] * npi / np.pi) % npi
			index3 = int(int_phi2[i][j] * npi / np.pi) % npi
			index4 = int(int_varphi2[i][j] * npi / np.pi) % npi
	
			int_P_z_theta_phi_varphi2[index1][index2][index3][index4] += 1
			int_rho_z_theta2[index1][index2] += 1
			int_rho_z_phi2[index1][index3] += 1
			int_rho_z_varphi2[index1][index4] += 1
			int_mol_count2[index1] += 1

	int_P_z_theta_phi_varphi = (int_P_z_theta_phi_varphi1 + int_P_z_theta_phi_varphi2) / 2.
	int_rho_z_theta = (int_rho_z_theta1 + int_rho_z_theta2) / 2.
	int_rho_z_phi = (int_rho_z_phi1 + int_rho_z_phi2) / 2.
	int_rho_z_varphi = (int_rho_z_varphi1 + int_rho_z_varphi2) / 2.
	int_mol_count = (int_mol_count1 + int_mol_count2) / 2.

	for index1 in xrange(nslice): 
		if mol_count[index1] != 0:
			P_z_theta_phi_varphi[index1] = P_z_theta_phi_varphi[index1] / mol_count[index1]
			rho_z_theta[index1] = rho_z_theta[index1] / mol_count[index1]
			rho_z_phi[index1] = rho_z_phi[index1] / mol_count[index1]
			rho_z_varphi[index1] = rho_z_varphi[index1] / mol_count[index1]

		if int_mol_count[index1] != 0:
			int_P_z_theta_phi_varphi[index1] = int_P_z_theta_phi_varphi[index1] / int_mol_count[index1]
			int_rho_z_theta[index1] = int_rho_z_theta[index1] / int_mol_count[index1]
			int_rho_z_phi[index1] = int_rho_z_phi[index1] / int_mol_count[index1]
			int_rho_z_varphi[index1] = int_rho_z_varphi[index1] / int_mol_count[index1]

		if int_mol_count1[index1] != 0:
			int_P_z_theta_phi_varphi1[index1] = int_P_z_theta_phi_varphi1[index1] / int_mol_count1[index1]
			int_rho_z_theta1[index1] = int_rho_z_theta1[index1] / int_mol_count1[index1]
			int_rho_z_phi1[index1] = int_rho_z_phi1[index1] / int_mol_count1[index1]
			int_rho_z_varphi1[index1] = int_rho_z_varphi1[index1] / int_mol_count1[index1]

		if int_mol_count2[index1] != 0:
			int_P_z_theta_phi_varphi2[index1] = int_P_z_theta_phi_varphi2[index1] / int_mol_count2[index1]
			int_rho_z_theta2[index1] = int_rho_z_theta2[index1] / int_mol_count2[index1]
			int_rho_z_phi2[index1] = int_rho_z_phi2[index1] / int_mol_count2[index1]
			int_rho_z_varphi2[index1] = int_rho_z_varphi2[index1] / int_mol_count2[index1]

	av_theta = np.zeros(nslice)
	av_phi = np.zeros(nslice)
	av_varphi = np.zeros(nslice)
	P1 = np.zeros(nslice)
	P2 = np.zeros(nslice)

	int_av_theta = np.zeros(nslice)
	int_av_phi = np.zeros(nslice)
	int_av_varphi = np.zeros(nslice)
	int_P1 = np.zeros(nslice)
	int_P2 = np.zeros(nslice)

	int_av_theta1 = np.zeros(nslice)
	int_av_phi1 = np.zeros(nslice)
	int_av_varphi1 = np.zeros(nslice)
	int_P11 = np.zeros(nslice)
	int_P21 = np.zeros(nslice)

	int_av_theta2 = np.zeros(nslice)
	int_av_phi2 = np.zeros(nslice)
	int_av_varphi2 = np.zeros(nslice)
	int_P12 = np.zeros(nslice)
	int_P22 = np.zeros(nslice)


	X_trig = np.linspace(0, np.pi, npi)
	X_trig1 = np.linspace(0, np.pi/2, npi)
	X_trig2 = np.linspace(0, np.pi/4, npi)

	for index1 in xrange(nslice): 
		for index2 in xrange(npi):
			av_theta[index1] += rho_z_theta[index1][index2] * X_trig[index2] # * 180./np.pi
			av_phi[index1] += rho_z_phi[index1][index2] * X_trig[index2]  # * 180./np.pi
			av_varphi[index1] += rho_z_varphi[index1][index2] * X_trig[index2]  # * 180./np.pi
			P1[index1] += rho_z_theta[index1][index2] * np.cos(X_trig[index2])
			P2[index1] += rho_z_theta[index1][index2] * 0.5 * (3 * np.cos(X_trig[index2])**2 - 1)

			int_av_theta[index1] += int_rho_z_theta[index1][index2] * X_trig[index2] # * 180./np.pi
			int_av_phi[index1] += int_rho_z_phi[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_av_varphi[index1] += int_rho_z_varphi[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_P1[index1] += int_rho_z_theta[index1][index2] * np.cos(X_trig[index2])
			int_P2[index1] += int_rho_z_theta[index1][index2] * 0.5 * (3 * np.cos(X_trig[index2])**2 - 1)

			int_av_theta1[index1] += int_rho_z_theta1[index1][index2] * X_trig[index2] # * 180./np.pi
			int_av_phi1[index1] += int_rho_z_phi1[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_av_varphi1[index1] += int_rho_z_varphi1[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_P11[index1] += int_rho_z_theta1[index1][index2] * np.cos(X_trig[index2])
			int_P21[index1] += int_rho_z_theta1[index1][index2] * 0.5 * (3 * np.cos(X_trig[index2])**2 - 1)

			int_av_theta2[index1] += int_rho_z_theta2[index1][index2] * X_trig[index2] # * 180./np.pi
			int_av_phi2[index1] += int_rho_z_phi2[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_av_varphi2[index1] += int_rho_z_varphi2[index1][index2] * X_trig[index2]  # * 180./np.pi
			int_P12[index1] += int_rho_z_theta2[index1][index2] * np.cos(X_trig[index2])
			int_P22[index1] += int_rho_z_theta2[index1][index2] * 0.5 * (3 * np.cos(X_trig[index2])**2 - 1)


	water_au_A = 0.5291772083

	water_exp_a = [1.528, 1.415, 1.468]
	water_CCSD_a_1 = np.array([10.18, 9.72, 9.87]) * 0.529**3
	water_CCSD_a_2 = np.array([10.11, 9.59, 9.78]) * 0.529**3
	water_CCSD_a_3 = np.array([10.09, 9.55, 9.75]) * 0.529**3
	water_CCSD_a_4 = np.array([9.98, 9.35, 9.61]) * 0.529**3
	water_ame_a = [1.672, 1.225, 1.328]
	water_abi_a = [1.47, 1.38, 1.42]
	water_tip_a = [0, 2.55, 0.82]

	water_exp_w = 514.5
	water_a0 = [10.683, 10.408, 10.534]
	water_S4 = [31.91, 66.22, 43.31]

	methanol_exp_a = [3.524, 3.091, 3.012]

	c = 514.5 / 0.08856

	w = 1000 / c

	#a = map (lambda i: (a0[i] + S4[i] * w**2) * au_A**3, range(3))
	
	if model.upper() == 'METHANOL':
		if a_type == 'exp': a = methanol_exp_a
	else:
		if a_type == 'exp': a = water_exp_a
		elif a_type == 'ame': a = water_ame_a
		elif a_type == 'abi': a = water_abi_a

	axx = np.zeros(nslice)
	azz = np.zeros(nslice)
	q1 = np.zeros(nslice)
	q2 = np.zeros(nslice)

	int_axx = np.zeros(nslice)
	int_azz = np.zeros(nslice)
	int_q1 = np.zeros(nslice)
	int_q2 = np.zeros(nslice)

	int_axx1 = np.zeros(nslice)
	int_azz1 = np.zeros(nslice)
	int_q11 = np.zeros(nslice)
	int_q21 = np.zeros(nslice)

	int_axx2 = np.zeros(nslice)
	int_azz2 = np.zeros(nslice)
	int_q12 = np.zeros(nslice)
	int_q22 = np.zeros(nslice)


	vd = DIM[0] * DIM[1] * DIM[2] / nslice

	print "PROCESSING POLARISABILITIES"
	for n in xrange(nslice):
		for i in xrange(npi):
			for j in xrange(npi):

				axx[n] += (a[0] * (np.cos(X_trig[i])**2 * np.cos(X_trig[j])**2 + np.sin(X_trig[j])**2) 
				+ a[1] * (np.cos(X_trig[i])**2 * np.sin(X_trig[j])**2 + np.cos(X_trig[j])**2) 
				+ a[2] * np.sin(X_trig[i])**2) * np.sum(P_z_theta_phi_varphi[n][i][j]) * 0.5

				azz[n] += (a[0] * np.sin(X_trig[i])**2 * np.cos(X_trig[j])**2 
				+ a[1] * np.sin(X_trig[i])**2 * np.sin(X_trig[j])**2 
				+ a[2] * np.cos(X_trig[i])**2) * np.sum(P_z_theta_phi_varphi[n][i][j])

				int_axx[n] += (a[0] * (np.cos(X_trig[i])**2 * np.cos(X_trig[j])**2 + np.sin(X_trig[j])**2) 
				+ a[1] * (np.cos(X_trig[i])**2 * np.sin(X_trig[j])**2 + np.cos(X_trig[j])**2) 
				+ a[2] * np.sin(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi[n][i][j]) * 0.5

				int_azz[n] += (a[0] * np.sin(X_trig[i])**2 * np.cos(X_trig[j])**2 
				+ a[1] * np.sin(X_trig[i])**2 * np.sin(X_trig[j])**2 
				+ a[2] * np.cos(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi[n][i][j])

				int_axx1[n] += (a[0] * (np.cos(X_trig[i])**2 * np.cos(X_trig[j])**2 + np.sin(X_trig[j])**2) 
				+ a[1] * (np.cos(X_trig[i])**2 * np.sin(X_trig[j])**2 + np.cos(X_trig[j])**2) 
				+ a[2] * np.sin(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi1[n][i][j]) * 0.5

				int_azz1[n] += (a[0] * np.sin(X_trig[i])**2 * np.cos(X_trig[j])**2 
				+ a[1] * np.sin(X_trig[i])**2 * np.sin(X_trig[j])**2 
				+ a[2] * np.cos(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi1[n][i][j])

				int_axx2[n] += (a[0] * (np.cos(X_trig[i])**2 * np.cos(X_trig[j])**2 + np.sin(X_trig[j])**2) 
				+ a[1] * (np.cos(X_trig[i])**2 * np.sin(X_trig[j])**2 + np.cos(X_trig[j])**2) 
				+ a[2] * np.sin(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi2[n][i][j]) * 0.5

				int_azz2[n] += (a[0] * np.sin(X_trig[i])**2 * np.cos(X_trig[j])**2 
				+ a[1] * np.sin(X_trig[i])**2 * np.sin(X_trig[j])**2 
				+ a[2] * np.cos(X_trig[i])**2) * np.sum(int_P_z_theta_phi_varphi2[n][i][j])


			q1[n] += (3 * np.cos(X_trig[i])**2 - 1) * rho_z_theta[n][i] * DEN[n] * 0.5 * np.pi / npi
			q2[n] += P2[n] * DEN[n] * np.pi / npi

			int_q1[n] += (3 * np.cos(X_trig[i])**2 - 1) * int_rho_z_theta[n][i] * int_av_mol_den[n] * 0.5 * np.pi / npi
			int_q2[n] += int_P2[n] * int_av_mol_den[n] * np.pi / npi

			int_q11[n] += (3 * np.cos(X_trig[i])**2 - 1) * int_rho_z_theta1[n][i] * w_den_1[n] * 0.5 * np.pi / npi
			int_q21[n] += int_P21[n] * w_den_1[n] * np.pi / npi

			int_q12[n] += (3 * np.cos(X_trig[i])**2 - 1) * int_rho_z_theta2[n][i] * w_den_2[n] * 0.5 * np.pi / npi
			int_q22[n] += int_P22[n] * w_den_2[n] * np.pi / npi

	plt.plot(range(len(int_axx)), axx)
	plt.plot(range(len(int_axx)), int_axx)
	plt.show()


	print ""
	print "WRITING TO FILE..."

	with file('{}/DATA/EULER/{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), csize, nslice, a_type, nimage), 'w') as outfile:
		np.savetxt(outfile, (axx,azz,q1,q2,av_theta,av_phi,av_varphi,P1,P2), fmt='%-12.6f')
	with file('{}/DATA/INTEULER/{}_{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), csize, nslice, a_type, nm, nimage), 'w') as outfile:
		np.savetxt(outfile, (int_axx,int_azz,int_q1,int_q2,int_av_theta,int_av_phi,int_av_varphi,int_P1,int_P2), fmt='%-12.6f')
	with file('{}/DATA/INTEULER/{}_{}_{}_{}_{}_{}_EUL1.txt'.format(root, model.lower(), csize, nslice, a_type, nm, nimage), 'w') as outfile:
		np.savetxt(outfile, (int_axx1,int_azz1,int_q11,int_q21,int_av_theta1,int_av_phi1,int_av_varphi1,int_P11,int_P21), fmt='%-12.6f')
	with file('{}/DATA/INTEULER/{}_{}_{}_{}_{}_{}_EUL2.txt'.format(root, model.lower(), csize, nslice, a_type, nm, nimage), 'w') as outfile:
		np.savetxt(outfile, (int_axx2,int_azz2,int_q12,int_q22,int_av_theta2,int_av_phi2,int_av_varphi2,int_P12,int_P22), fmt='%-12.6f')
							
	print "{} {} {} COMPLETE\n".format(root, model.upper(), csize)


def local_frame_molecule(molecule, model):
	
	if model.upper() == 'METHANOL': 
		d = np.subtract(molecule[2], molecule[3])
		t = np.subtract(molecule[4], molecule[1])
	else: 
		d = np.add(np.subtract(molecule[0], molecule[1]), np.subtract(molecule[0],molecule[2]))
		t = np.subtract(molecule[1], molecule[2])

	d = ut.unit_vector(d[0], d[1], d[2])
	t = ut.unit_vector(t[0], t[1], t[2])
	n = np.cross(d, t)
	
	B = np.array([[n[0], t[0], d[0]], [n[1], t[1], d[1]], [n[2], t[2], d[2]]])
	
	return B


def main(TYPE):

	"INPUT DATA"

	if TYPE[-2].upper() == 'TEST':

		#model = 'SPCE'
		model = 'TIP4P2005'
		model = 'METHANOL'
		nsite, AT, Q, M, LJ = ut.get_param(model)
		sigma = np.max(LJ[1])
		lslice = 0.05 * sigma
		print lslice
		cutoff = 18
		vlim = 3
		ncube = 3
		CSIZE = ([50])
		#CSIZE = ([40])
		ndim = len(CSIZE)
		nimage = 2000
		a_type = 'exp'
		suffix = "surface"
		nfolder = 1
		T = 298

		for n in xrange(nfolder):
			force = 0
			if force == 0: folder = "SURFACE"
			elif force == 1: folder = "SURFACE_2"
			#n+=1
			#folder = "SURFACE_{}".format(n)

			for i in xrange(ndim):
		
				#if force == 0: root = '/data/fl7g13/AMBER/OLD/{}/CUT_{}_A/{}_{}/VARIATION/{}'.format(model.upper(), cutoff, model.upper(), CSIZE[i], folder.upper())
				#elif force == 1: root = '/data/fl7g13/AMBER/OLD/{}/CUT_{}_A/{}_{}/JANECEK/{}'.format(model.upper(), cutoff, model.upper(), CSIZE[i], folder.upper())
				#elif force == 2: root = '/data/fl7g13/AMBER/OLD/{}/CUT_{}_A/{}_{}/KPOINTS/{}'.format(model.upper(), cutoff, model.upper(), CSIZE[i], folder.upper())
				#elif force == 3: root = '/data/fl7g13/AMBER/OLD/{}/CUT_{}_A/{}_{}/EWALD/{}'.format(model.upper(), cutoff, model.upper(), CSIZE[i], folder.upper())
				if model.upper() == 'METHANOL': root = '/data/fl7g13/AMBER/{}/T_{}_K/CUT_{}_A/{}_{}'.format(model.upper(), T, cutoff, model.upper(), CSIZE[i])
				else: root = '/data/fl7g13/AMBER/WATER/{}/T_{}_K/CUT_{}_A/{}_{}'.format(model.upper(), T, cutoff, model.upper(), CSIZE[i])

				if not os.path.exists('{}/{}/{}_{}_{}_{}.nc'.format(root, folder.upper(), model.lower(), CSIZE[i], suffix, nimage)): 
					ut.make_nc(root, folder.upper(),  model.lower(), CSIZE[i], suffix, nimage)
				traj = ut.load_nc(root, folder.upper())							
				root = '{}/{}'.format(folder.upper())

				natom = traj.n_atoms
				nmol = traj.n_residues
				DIM = np.array(traj.unitcell_lengths[0]) * 10
				nslice = int(DIM[2] / lslice)
				nm = int(DIM[0] / sigma)
				nxy = 30
		
				if not os.path.exists("{}/DATA".format(root)): os.mkdir("{}/DATA".format(root))
				#"""
				if not os.path.exists("{}/DATA/DEN".format(root)): os.mkdir("{}/DATA/DEN".format(root))
				if os.path.exists('{}/DATA/DEN/{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, nimage)):
					print "FILE FOUND '{}/DATA/DEN/{}_{}_{}_{}_DEN.txt".format(root, model.lower(), CSIZE[i], nslice, nimage)
					overwrite = raw_input("OVERWRITE? (Y/N): ")
					if overwrite.upper() == 'Y': 
						ow_all = raw_input("OVERWRITE ALL? (Y/N): ")	
						mass_profile(traj, root, nimage, nslice, natom, nsite, model, folder, CSIZE[i], suffix, DIM, ow_all)
								
				else: mass_profile(traj, root, nimage, nslice, natom, nsite, model, folder, CSIZE[i], suffix, DIM, 'N')
				
				if not os.path.exists("{}/DATA/ACOEFF".format(root)): os.mkdir("{}/DATA/ACOEFF".format(root))
				if not os.path.exists("{}/DATA/INTDEN".format(root)): os.mkdir("{}/DATA/INTDEN".format(root))
				if os.path.exists('{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, nm, nimage)):
					print "\nFILE FOUND '{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt".format(root, model.lower(), CSIZE[i], nslice, nm, nimage)
					overwrite = raw_input("OVERWRITE? (Y/N): ")
					if overwrite.upper() == 'Y': 
						ow_coeff = raw_input("OVERWRITE ACOEFF? (Y/N): ")
						ow_curve = raw_input("OVERWRITE CURVE? (Y/N): ")
						ow_count = raw_input("OVERWRITE COUNT? (Y/N): ")
						intrinsic_profile(traj, root, nimage, nslice, ncube, natom, model, CSIZE[i], suffix, DIM, vlim, nxy, ow_coeff, ow_count, ow_curve)
				else: intrinsic_profile(traj, root, nimage, nslice, ncube, natom, model, CSIZE[i], suffix, sigma, nsite, AT, DIM, M, vlim, nxy, 'N','N', 'N')

				#"""
				if not os.path.exists("{}/DATA/EULER".format(root)): os.mkdir("{}/DATA/EULER".format(root))
				if not os.path.exists("{}/DATA/INTEULER".format(root)): os.mkdir("{}/DATA/INTEULER".format(root))
				if os.path.exists('{}/DATA/EULER/{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)):
					print '\nFILE FOUND {}/DATA/EULER/{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)
					overwrite = raw_input("OVERWRITE? (Y/N): ")
					if overwrite.upper() == 'Y':  
						ow_P = raw_input("OVERWRITE ANGLES? (Y/N): ") 
						eul_profile(traj, root, nimage, nslice, nmol, model, CSIZE[i], suffix, DIM, nsite, a_type, nm, nxy, ow_P)
				else: eul_profile(traj, root, nimage, nslice, nmol, model, CSIZE[i], suffix, DIM, nsite, a_type, nm, nxy, 'N')
		
				import dielectric as di
				if not os.path.exists("{}/DATA/DIELEC".format(root)): os.mkdir("{}/DATA/DIELEC".format(root))
				if os.path.exists('{}/DATA/DIELEC/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)):
					print '\nFILE FOUND {}/DATA/DIELEC/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)
					overwrite = raw_input("OVERWRITE? (Y/N): ")
					if overwrite.upper() == 'Y':  
						ow_A = raw_input("OVERWRITE ACOUNT? (Y/N): ") 
						di.dielectric_refractive_index(root, model, CSIZE[i], nslice, nimage, a_type, force, nm, nxy, DIM, ow_A)
				else:di.dielectric_refractive_index(root, model, CSIZE[i], nslice, nimage, a_type, force, nm, nxy, DIM, 'Y')

				import graphs
				groot = "/home/fl7g13/Documents/Figures/{}_{}_{}".format(model.upper(),CSIZE[i],cutoff)
				if not os.path.exists(groot): os.mkdir(groot)
				graphs.print_graphs(root, groot, model, CSIZE[i], nslice, nimage, a_type, force, nm, DIM)
				#"""

	else: 
		model = raw_input("What model?: ")

		nsite, AT, Q, M, LJ = ut.get_param(model)
		sigma = np.max(LJ[1])
		lslice = 0.05 * sigma
		vlim = 3
		ncube = 3
		T = int(raw_input("Temperature: (K) "))
		cutoff = int(raw_input("Cutoff: (A) "))

		CSIZE = []
		ndim = int(raw_input("No. of dimensions: "))
		nimage = int(raw_input("Number of images: "))

		force = raw_input("VDW Force corrections? (Y/N): ")
		if force.upper() == 'Y': folder = 'SURFACE_2'
		else: folder = 'SURFACE' 
		suffix = 'surface'
		a_type = 'exp'	

		for type_ in TYPE:
			for i in xrange(ndim):
				CSIZE.append(5 * i + 50)
				if model.upper() == 'ARGON' or model.upper() == 'METHANOL': root = '/data/fl7g13/AMBER/{}/T_{}_K/CUT_{}_A/{}_{}'.format(model.upper(), T, cutoff, model.upper(), CSIZE[i])
				else: root = '/data/fl7g13/AMBER/WATER/{}/T_{}_K/CUT_{}_A/{}_{}'.format(model.upper(), T, cutoff, model.upper(), CSIZE[i])

				if not os.path.exists('{}/{}/{}_{}_{}_{}.nc'.format(root, folder.upper(), model.lower(), CSIZE[i], suffix, nimage)): 
					ut.make_nc(root, folder.upper(),  model.lower(), CSIZE[i], suffix, nimage)
				traj = ut.load_nc(root, folder.upper())							
				root = '{}/{}'.format(folder.upper())

				natom = traj.n_atoms
				nmol = traj.n_residues
				DIM = np.array(traj.unitcell_lengths[0]) * 10
				nslice = int(DIM[2] / lslice)
				nm = int(DIM[0] / sigma)
				nxy = 30
		
				if not os.path.exists("{}/DATA".format(root)): os.mkdir("{}/DATA".format(root))

				if type_.upper() == 'DEN':
					if os.path.exists('{}/DATA/DEN/{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, nimage)):
						print "FILE FOUND '{}/DATA/DEN/{}_{}_{}_{}_DEN.txt".format(root, model.lower(), CSIZE[i], nslice, nimage)
						overwrite = raw_input("OVERWRITE? (Y/N): ")
						if overwrite.upper() == 'Y': 
							ow_count = raw_input("OVERWRITE COUNT? (Y/N): ")	
							mass_profile(traj, root, nimage, nslice, natom, nsite, model, folder, CSIZE[i], suffix, DIM, ow_count)		
					else: mass_profile(traj, root, nimage, nslice, natom, nsite, model, folder, CSIZE[i], suffix, DIM, 'N')

				if type_.upper() == 'INT':
					if not os.path.exists("{}/DATA/ACOEFF".format(root)): os.mkdir("{}/DATA/ACOEFF".format(root))
					if not os.path.exists("{}/DATA/INTDEN".format(root)): os.mkdir("{}/DATA/INTDEN".format(root))
					if os.path.exists('{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt'.format(root, model.lower(), CSIZE[i], nslice, nm, nimage)):
						print "\nFILE FOUND '{}/DATA/INTDEN/{}_{}_{}_{}_{}_DEN.txt".format(root, model.lower(), CSIZE[i], nslice, nm, nimage)
						overwrite = raw_input("OVERWRITE? (Y/N): ")
						if overwrite.upper() == 'Y': 
							ow_coeff = raw_input("OVERWRITE ACOEFF? (Y/N): ")
							ow_curve = raw_input("OVERWRITE CURVE? (Y/N): ")
							ow_count = raw_input("OVERWRITE COUNT? (Y/N): ")
							intrinsic_profile(traj, root, nimage, nslice, ncube, natom, model, CSIZE[i], suffix, DIM, vlim, nxy, ow_coeff, ow_count, ow_curve)
					else: intrinsic_profile(traj, root, nimage, nslice, ncube, natom, model, CSIZE[i], suffix, DIM, vlim, nxy,'N','N', 'N')

				if type_.upper() == 'EUL':
					if not os.path.exists("{}/DATA/EULER".format(root)): os.mkdir("{}/DATA/EULER".format(root))
					if not os.path.exists("{}/DATA/INTEULER".format(root)): os.mkdir("{}/DATA/INTEULER".format(root))
					if os.path.exists('{}/DATA/EULER/{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)):
						print '\nFILE FOUND {}/DATA/EULER/{}_{}_{}_{}_{}_EUL.txt'.format(root, model.lower(), CSIZE[i], nslice, a_type, nimage)
						overwrite = raw_input("OVERWRITE? (Y/N): ")
						if overwrite.upper() == 'Y':  
							ow_P = raw_input("OVERWRITE ANGLES? (Y/N): ") 
							eul_profile(root, nimage, nslice, nmol, model, CSIZE[i], suffix, DIM, nsite, a_type, nm, nxy, ow_P)
					else: eul_profile(root, nimage, nslice, nmol, model, CSIZE[i], suffix, DIM, nsite, a_type, nm, nxy, 'N')
		

